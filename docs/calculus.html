<html>
<head>
<title>Math - Calculus</title>
<link rel="stylesheet" type="text/css" href="style.css">
<style></style>
</head>

<body>

<br id="differentiation"/>
<h1>Differentiation</h1>

<p><b>diff( <i>f</i>, <i>x</i> )</b> &mdash; numerical derivative of a real or complex function at <i>x</i></p>

<p><b>diff( <i>f</i>, <i>x</i>, <i>n</i> )</b> &mdash; <i>n</i>th-order numerical derivative of a real or complex function at <i>x</i></p>

<p><b>D( <i>f</i>, <i>x</i> )</b> &mdash; numerical derivative of a real or complex function at <i>x</i></p>

<p><b>D( <i>f</i>, <i>x</i>, <i>n</i> )</b> &mdash; <i>n</i>th-order numerical derivative of a real or complex function at <i>x</i></p>

<br id="integration"/>
<h1>Integration</h1>

<p><b>integrate( <i>f</i>, [<i>a</i>,<i>b</i>] )</b> &mdash; numerical integral of a real or complex function on the interval [<i>a</i>,<i>b</i>] by an adaptive Simpson algorithm</p>

<p><b>integrate( <i>f</i>, [<i>a</i>,<i>b</i>], method )</b> &mdash; numerical integral of a real or complex function on the interval [<i>a</i>,<i>b</i>] by method <nobr><code>'euler-maclaurin'</code></nobr>, <code>'romberg'</code>, <nobr><code>'adaptive-simpson'</code></nobr>, <nobr><code>'tanh-sinh'</code></nobr> or <code>'gaussian'</code></p>

<p><b>discreteIntegral( values, step )</b> &mdash; numerical integral over discrete real values separated by step using Euler-Maclaurin summation</p>

<br id="interpolation"/>
<h1>Interpolation</h1>

<p><b>polynomial( <i>x</i>, coefficients )</b> &mdash; value of polynomial with real coefficients at <i>x</i> by Horner&rsquo;s method with the coefficient of the highest power first</p>

<p><b>polynomial( <i>x</i>, coefficients, <code>true</code> )</b> &mdash; value of polynomial with real coefficients and its derivative at <i>x</i> by Horner&rsquo;s method returned as <nobr><code>{ polynomial: polynomial, derivative: derivative }</code></nobr></p>

<p><b>partialBell( <i>n</i>, <i>k</i>, arguments )</b> &mdash; partial Bell polynomial with integer indices <i>n</i> and <i>k</i> and an array of length <i>n</i>&minus;<i>k</i>+1 of real arguments</p>

<p><b>findRoot( <i>f</i>, [<i>a</i>,<i>b</i>] )</b> &mdash; numerical root of a real function on the interval [<i>a</i>,<i>b</i>] by bisection</p>

<p><b>findRoot( <i>f</i>, <i>a</i> )</b> &mdash; numerical root of a real or complex function starting from <i>a</i> by Newton&rsquo;s method</p>

<p><b>spline( points )</b> &mdash; interpolating cubic spline over the array of two-dimensional points</p>

<p><b>spline( points, value )</b> &mdash; interpolating cubic spline over the array of two-dimensional points with a returned value of <code>'function'</code>, <code>'derivative'</code> or <code>'integral'</code></p>

<br id="diffeq"/>
<h1>Differential Equations</h1>

<p><b>ode( <i>f</i>, <i>y</i><sub>0</sub>, [<i>x</i><sub>0</sub>,<i>x</i><sub>1</sub>] )</b> &mdash; numerical solution of the system <i>dy</i>/<i>dx</i>&nbsp;=&nbsp;<i>f</i>(<i>x</i>,<i>y</i>), <i>y</i>(0)&nbsp;=&nbsp;<i>y</i><sub>0</sub> on the specified interval. The function and initial condition should be vectorized for higher-order systems. The solution is returned as an array of arrays of data points, with the independent variable as the first item in each data point array.</p>

<p><b>ode( <i>f</i>, <i>y</i><sub>0</sub>, [<i>x</i><sub>0</sub>,<i>x</i><sub>1</sub>], step, method )</b> &mdash; numerical solution of the system <i>dy</i>/<i>dx</i>&nbsp;=&nbsp;<i>f</i>(<i>x</i>,<i>y</i>), <i>y</i>(0)&nbsp;=&nbsp;<i>y</i><sub>0</sub> on the specified interval with specified step size and a method of <code>'euler'</code> or <nobr><code>'runge-kutta'</code></nobr>. The function and initial condition should be vectorized for higher-order systems. The solution is returned as an array of arrays of data points, with the independent variable as the first item in each data point array.</p>

</body>
</html>
